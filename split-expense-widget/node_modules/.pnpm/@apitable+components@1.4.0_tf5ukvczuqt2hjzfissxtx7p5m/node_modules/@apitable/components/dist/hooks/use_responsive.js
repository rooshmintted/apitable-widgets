/**
 * APITable <https://github.com/apitable/apitable>
 * Copyright (C) 2022 APITable Ltd. <https://apitable.com>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
import { useSize } from 'ahooks';
import { useEffect, useState } from 'react';
import { ScreenWidth } from '@apitable/core';
const isRenderServer = () => {
    return process.env.SSR;
};
export var ScreenSize;
(function (ScreenSize) {
    ScreenSize["xs"] = "xs";
    ScreenSize["sm"] = "sm";
    ScreenSize["md"] = "md";
    ScreenSize["lg"] = "lg";
    ScreenSize["xl"] = "xl";
    ScreenSize["xxl"] = "xxl";
    ScreenSize["xxxl"] = "xxxl";
})(ScreenSize || (ScreenSize = {}));
const breakpoints = ScreenWidth;
const sizes = Object.entries(breakpoints).sort(([, aSize], [, bSize]) => bSize - aSize);
export const getScreen = (width, height) => {
    var _a;
    // @ts-ignore
    const size = ((_a = sizes.find(([, size]) => size < width)) === null || _a === void 0 ? void 0 : _a[0]) || sizes[sizes.length - 1][0];
    const orientation = width > height ? 'landscape' : 'portrait';
    const screenIsAtLeast = (breakpoint, andOrientation) => {
        return width >= breakpoints[breakpoint] && (!andOrientation || andOrientation === orientation);
    };
    const screenIsAtMost = (breakpoint, andOrientation) => {
        return width < breakpoints[breakpoint] && (!andOrientation || andOrientation === orientation);
    };
    return {
        size,
        orientation,
        screenIsAtLeast,
        screenIsAtMost,
        clientWidth: width,
        isMobile: screenIsAtMost(ScreenSize.md),
    };
};
export const useResponsive = () => {
    const [bodySize, setBodySize] = useState(() => {
        const el = isRenderServer() ? null : document.body;
        return {
            width: el === null || el === void 0 ? void 0 : el.clientWidth,
            height: el === null || el === void 0 ? void 0 : el.clientHeight,
        };
    });
    const size = useSize(isRenderServer() ? undefined : document.body);
    useEffect(() => {
        if (size) {
            setBodySize(size);
        }
    }, [size, setBodySize]);
    // @ts-ignore
    if (sizes[sizes.length - 1][1] !== 0) {
        // @ts-ignore
        console.warn('fixing', sizes[sizes.length - 1][0], 'size which should be 0');
        // @ts-ignore
        sizes[sizes.length - 1][1] = 0;
    }
    const [screen, setScreen] = useState(getScreen(bodySize === null || bodySize === void 0 ? void 0 : bodySize.width, bodySize === null || bodySize === void 0 ? void 0 : bodySize.height));
    useEffect(() => {
        setScreen(getScreen(bodySize === null || bodySize === void 0 ? void 0 : bodySize.width, bodySize === null || bodySize === void 0 ? void 0 : bodySize.height));
        // eslint-disable-next-line
    }, [bodySize, setScreen]);
    return screen;
};
