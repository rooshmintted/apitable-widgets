"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AppHook = void 0;
const listeners_1 = require("./listeners");
class AppHook {
    constructor() {
        /**
         * the place to store all listeners, including Trigger and Filter, store them by type
         *
         * @type {IListenersMap}
         * @memberof AppHook
         */
        this._listeners = {};
    }
    // async applyFiltersAsync<T>(hook: string, defaultValue: any, hookState?: any): Promise<T> {
    //     return await ;
    // }
    /**
     *
     * Add Trigger
     *
     * @param {string} hook
     * @param {TriggerCommand} command
     * @param {*} commandArg
     * @param {(IRule | undefined)} rule
     * @param {number} [priority=0]
     * @param {boolean} [isCatch=false]
     * @returns {ITrigger}
     * @memberof AppHook
     */
    addTrigger(hook, command, commandArg, rule, priority = 0, isCatch = false) {
        if (this._onAddTrigger != null) {
            this._onAddTrigger(hook, command, commandArg, rule, priority, isCatch);
        }
        const action = {
            command,
            args: commandArg,
        };
        const trigger = {
            type: listeners_1.ListenerType.Filter,
            priority,
            hook,
            action,
            rule,
            isCatch,
        };
        this.addListener(listeners_1.ListenerType.Trigger, hook, trigger);
        return trigger;
    }
    /**
     * Bind AddTriggerEvent, the method will be called when addTrigger
     *
     * @memberof AppHook
     */
    bindAddTrigger(bind) {
        this._onAddTrigger = bind;
    }
    /**
     *
     * bind AddFilterEvent, the method will be called when addFilter
     *
     * @param {AddFilterEvent} bind
     * @memberof AppHook
     */
    bindAddFilter(bind) {
        this._onAddFilter = bind;
    }
    /**
     * Bind DoTriggerEvent, the method will be called when doTrigger
     *
     * @param {DoTriggerEvent} bind
     * @memberof AppHook
     */
    bindDoTrigger(bind) {
        this._onDoTrigger = bind;
    }
    /**
     * binding the method will be called when applyFilters
     *
     * @param {WhenApplyFiltersEvent} bind
     * @memberof AppHook
     */
    bindUseFilters(bind) {
        this._whenApplyFilters = bind;
    }
    /**
     *
     * Add filter, filter the default value when event is fired
     *
     * @param {string} hook
     * @param {FilterCommand} command
     * @param {*} commandArg
     * @param {(IRule | undefined)} rule
     * @param {number} [priority=0]
     * @param {boolean} [isCatch=false]
     * @returns {IFilter}
     * @memberof AppHook
     */
    addFilter(hook, command, commandArg, rule, priority = 0, isCatch = false) {
        if (this._onAddFilter != null) {
            this._onAddFilter(hook, command, commandArg, rule, priority, isCatch);
        }
        const action = {
            command,
            args: commandArg,
        };
        const filter = {
            type: listeners_1.ListenerType.Filter,
            priority,
            hook,
            action,
            rule,
            isCatch,
        };
        this.addListener(listeners_1.ListenerType.Filter, hook, filter);
        return filter;
    }
    /**
     * add listener to the listeners map
     *
     * @private
     * @param {('Trigger' | 'Filter')} type
     * @param {string} hook hook name
     * @param {IListener} newListener
     * @memberof AppHook
     */
    addListener(type, hook, newListener) {
        // listeners of the type
        let typeListners = this._listeners[type];
        if (typeListners === undefined) {
            typeListners = this._listeners[type] = {};
        }
        let listenerList = typeListners[hook];
        if (listenerList === undefined) {
            listenerList = typeListners[hook] = [newListener];
        }
        else {
            // order insert, the smaller the number, the more small index.
            for (let i = 0; i <= listenerList.length; i++) {
                const loopListener = listenerList[i];
                if (i === listenerList.length) { // number biggest
                    listenerList.push(newListener);
                    break;
                }
                if (newListener.priority <= loopListener.priority) {
                    listenerList.splice(i, 0, newListener);
                    break;
                }
            }
        }
    }
    /**
     * remove listener
     *
     * @private
     * @param {ListenerType} type
     * @param {IListener} listener
     * @returns {boolean}
     * @memberof AppHook
     */
    removeListener(type, listener) {
        const typeListners = this._listeners[type];
        if (typeListners === undefined) {
            return false;
        }
        const listenerList = typeListners[listener.hook];
        if (listenerList === undefined) {
            return false;
        }
        for (let i = 0; i < listenerList.length; i++) {
            const l = listenerList[i];
            if (l === listener) {
                listenerList.splice(i, 1);
                return true;
            }
        }
        return false;
    }
    /**
     * active the trigger, map the trigger to the command
     * no need to consider the priority, because the priority is considered when add trigger
     *
     * @param {string} hook
     * @param {object} [hookState={}] hook event state, optional arguments
     * @memberof AppHook
     */
    doTriggers(hook, hookState) {
        if (this._onDoTrigger != null) {
            this._onDoTrigger(hook, hookState);
        }
        const triggerMap = this._listeners[listeners_1.ListenerType.Trigger];
        if (triggerMap === undefined) {
            return;
        }
        const triggerList = triggerMap[hook];
        if (triggerList === undefined) {
            return;
        }
        for (let i = 0; i < triggerList.length; i++) {
            const trigger = triggerList[i];
            if (trigger.isCatch === undefined || trigger.isCatch === false) {
                trigger.action.command(hookState, trigger.action.args);
            }
            else {
                try {
                    trigger.action.command(hookState, trigger.action.args);
                }
                catch (e) {
                    console.error(e);
                }
            }
        }
    }
    /**
     *
     * remove triggers
     *
     * attention: pass the correct trigger reference(ref func pointer)
     * no deep comparison here
     *
     * @param {ITrigger} trigger
     * @returns {boolean}
     * @memberof AppHook
     */
    removeTrigger(trigger) {
        return this.removeListener(listeners_1.ListenerType.Trigger, trigger);
    }
    /**
     * whether has any specified hook name trigger
     *
     * @param {string} hook
     * @returns {boolean}
     * @memberof AppHook
     */
    hasAnyTriggers(hook) {
        return this.hasAnyListeners(listeners_1.ListenerType.Trigger, hook);
    }
    /**
     * whether has any specified hook name filter
     *
     * @param {string} hook
     * @returns {boolean}
     * @memberof AppHook
     */
    hasAnyFilters(hook) {
        return this.hasAnyListeners(listeners_1.ListenerType.Filter, hook);
    }
    /**
     * whether has any specified hook name listener(filter or trigger)
     *
     * @private
     * @param {ListenerType} type
     * @param {string} hook
     * @returns {boolean}
     * @memberof AppHook
     */
    hasAnyListeners(type, hook) {
        const typeListeners = this._listeners[type];
        if (typeListeners === undefined) {
            return false;
        }
        const hookListeners = typeListeners[hook];
        if (hookListeners === undefined) {
            return false;
        }
        if (hookListeners.length === 0) {
            return false;
        }
        return true;
    }
    /**
     * remove filter
     *
     * attention: pass the correct trigger reference(ref func pointer)
     * no deep comparison here
     *
     * @param {IFilter} filter
     * @returns {boolean}
     * @memberof AppHook
     */
    removeFilter(filter) {
        return this.removeListener(listeners_1.ListenerType.Filter, filter);
    }
    /**
     * apply filters, trigger the event, and implement multiple filters on the original string
     *
     * @param {string} hook
     * @param {*} defaultValue
     * @param {*} [hookState]
     * @returns {*}
     * @memberof AppHook
     */
    applyFilters(hook, defaultValue, hookState) {
        if (this._whenApplyFilters != null) {
            this._whenApplyFilters(hook, defaultValue, hookState);
        }
        const filterMap = this._listeners[listeners_1.ListenerType.Filter];
        if (filterMap === undefined) {
            return defaultValue;
        }
        const filterList = filterMap[hook];
        if (filterList === undefined) {
            return defaultValue;
        }
        let filteredValue = defaultValue;
        for (let i = 0; i < filterList.length; i++) {
            const filter = filterList[i];
            if (filter.isCatch === undefined || filter.isCatch === false) {
                filteredValue = filter.action.command(filteredValue, hookState, filter.action.args);
            }
            else {
                try {
                    filteredValue = filter.action.command(filteredValue, hookState, filter.action.args);
                }
                catch (e) {
                    console.error(e);
                }
            }
        }
        return filteredValue;
    }
}
exports.AppHook = AppHook;
//# sourceMappingURL=apphook.js.map