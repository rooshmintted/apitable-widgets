/**
 * APITable <https://github.com/apitable/apitable>
 * Copyright (C) 2022 APITable Ltd. <https://apitable.com>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
import { ChevronDownOutlined } from '@apitable/icons';
import { useClickAway, useToggle } from 'ahooks';
import Color from 'color';
import { SelectItem } from '../../components/select/select_item';
import { convertChildrenToData } from '../../components/select/utils';
import { WrapperTooltip } from '../../components/tooltip';
import { stopPropagation } from '../../helper';
import { useProviderTheme } from '../../hooks';
import Trigger from 'rc-trigger';
import React, { useEffect, useMemo, useRef, useState } from 'react';
import Highlighter from 'react-highlight-words';
import { ListDeprecate } from '../list_deprecate';
import { GlobalStyle, hightLightCls, OptionOutside, StyledArrowIcon, StyledListContainer, StyledSelectedContainer, StyledSelectTrigger } from './styled';
import debounce from 'lodash/debounce';
const _renderValue = (option) => {
    return option.label;
};
const _Highlighter = Highlighter;
const _GlobalStyle = GlobalStyle;
/**
 * @deprecated
 * please use DropdownSelect instead ,  rc-trigger is deprecated
 * @param props
 * @constructor
 */
export const Select = (props) => {
    const { placeholder, value, triggerStyle, triggerCls, options: _options, prefixIcon, suffixIcon, dropdownMatchSelectWidth = true, openSearch = false, searchPlaceholder, highlightStyle, noDataTip, defaultVisible, hiddenArrow = false, triggerLabel, onSelected, hideSelectedOption, dropdownRender, disabled, disabledTip, listStyle, listCls, renderValue = _renderValue, children, maxListWidth = 240, popupStyle = {} } = props;
    const [isInit, setIsInit] = useState(true);
    const theme = useProviderTheme();
    const inputRef = useRef(null);
    const triggerRef = useRef();
    const listContainer = useRef(null);
    const [visible, { toggle: toggleVisible, set: setVisible }] = useToggle(false);
    const containerRef = useRef(null);
    const [keyword, setKeyword] = React.useState('');
    const options = useMemo(() => {
        return _options == null ? convertChildrenToData(children) : _options;
    }, [children, _options]);
    const [triggerInfo, setTriggerInfo] = useState();
    const OFFSET = [0, 4];
    const selectedOption = options.filter(item => Boolean(item)).find(item => item.value === value);
    const setKeywordDebounce = debounce(setKeyword, 300);
    const inputOnChange = (_e, keyword) => {
        setKeywordDebounce(keyword);
    };
    useEffect(() => {
        if (defaultVisible != null && isInit) {
            setIsInit(false);
            setVisible(defaultVisible);
            return;
        }
        setVisible(false);
        // eslint-disable-next-line
    }, [value, toggleVisible, defaultVisible, isInit]);
    useEffect(() => {
        setKeyword('');
    }, [visible, value]);
    useEffect(() => {
        if (triggerRef.current) {
            const size = triggerRef.current.getRootDomNode().getBoundingClientRect();
            setTriggerInfo({ triggerSize: size, triggerOffset: OFFSET, adjust: true });
        }
        // eslint-disable-next-line
    }, [triggerRef]);
    useClickAway(() => {
        setVisible(false);
    }, containerRef, 'click');
    const renderOptionItem = (item, index) => {
        return React.createElement(OptionOutside, Object.assign({ currentIndex: index, id: item.value, key: `${item.value}-${index}` }, item),
            React.createElement(SelectItem, { item: item, renderValue: _renderValue, isChecked: value === item.value }, !keyword ? null : React.createElement(_Highlighter, { highlightClassName: hightLightCls.toString(), highlightStyle: highlightStyle, searchWords: [keyword], autoEscape: true, textToHighlight: item.label })));
    };
    const optionsFilter = (item) => {
        if (!item) {
            return false;
        }
        if (hideSelectedOption && item.value === value) {
            return false;
        }
        if (keyword && item.label) {
            // Search supports case, refer to the antd rc select library
            return item.label.toUpperCase().includes(keyword.toUpperCase());
        }
        return true;
    };
    const afterFilterOptions = options.filter(optionsFilter);
    const renderOptionList = () => {
        var _a, _b;
        return (React.createElement(StyledListContainer, { width: dropdownMatchSelectWidth ? ((_a = containerRef.current) === null || _a === void 0 ? void 0 : _a.clientWidth) + 'px' : 'auto', minWidth: !dropdownMatchSelectWidth ? ((_b = containerRef.current) === null || _b === void 0 ? void 0 : _b.clientWidth) + 'px' : 'auto', onClick: stopPropagation, className: listCls, style: Object.assign(Object.assign({}, listStyle), { maxWidth: dropdownMatchSelectWidth ? '' : maxListWidth }), ref: listContainer }, dropdownRender || React.createElement(ListDeprecate, { onClick: (_e, index) => {
                setVisible(false);
                onSelected && onSelected(afterFilterOptions[index], index);
            }, searchProps: openSearch ? {
                inputRef: inputRef,
                onSearchChange: inputOnChange,
                placeholder: searchPlaceholder,
            } : undefined, noDataTip: noDataTip, triggerInfo: triggerInfo, autoHeight: true }, afterFilterOptions.map((item, index) => {
            return renderOptionItem(item, index);
        }))));
    };
    const checked2View = () => {
        setTimeout(() => {
            var _a;
            const selectedItemElement = (_a = listContainer.current) === null || _a === void 0 ? void 0 : _a.querySelector('.isChecked');
            selectedItemElement === null || selectedItemElement === void 0 ? void 0 : selectedItemElement.scrollIntoView({ block: 'nearest' });
        }, 20);
    };
    const triggerClick = () => {
        if (disabled) {
            return;
        }
        if (!visible) {
            setTimeout(() => {
                openSearch && inputRef.current && inputRef.current.focus();
            }, 100);
        }
        toggleVisible();
        checked2View();
    };
    return React.createElement(React.Fragment, null,
        React.createElement(_GlobalStyle, null),
        React.createElement(Trigger
        // getPopupContainer={() => containerRef.current!}
        , { 
            // getPopupContainer={() => containerRef.current!}
            popup: renderOptionList, destroyPopupOnHide: true, popupAlign: { points: ['tl', 'bl'], offset: OFFSET, overflow: { adjustX: true, adjustY: true } }, popupStyle: Object.assign({ width: 'max-content', position: 'absolute', zIndex: 1200 }, popupStyle), ref: triggerRef, popupVisible: visible },
            React.createElement(WrapperTooltip, { wrapper: Boolean(disabledTip && disabled), tip: disabledTip },
                React.createElement(StyledSelectTrigger, { onClick: triggerClick, style: triggerStyle, className: triggerCls, tabIndex: -1, ref: containerRef, disabled: Boolean(disabled), focus: visible, "data-name": 'select' },
                    React.createElement(StyledSelectedContainer, Object.assign({ className: 'ellipsis' }, selectedOption, { disabled: Boolean(disabled || (selectedOption && selectedOption.disabled)), suffixIcon: suffixIcon || (selectedOption === null || selectedOption === void 0 ? void 0 : selectedOption.suffixIcon), prefixIcon: prefixIcon || (selectedOption === null || selectedOption === void 0 ? void 0 : selectedOption.prefixIcon) }),
                        triggerLabel,
                        !triggerLabel && (value != null && selectedOption ? React.createElement(SelectItem, { item: Object.assign(Object.assign({}, selectedOption), { suffixIcon: suffixIcon || selectedOption.suffixIcon, prefixIcon: prefixIcon || selectedOption.prefixIcon }), renderValue: renderValue }) :
                            React.createElement("span", { className: 'placeholder ellipsis' }, placeholder))),
                    !hiddenArrow && React.createElement(StyledArrowIcon, { rotated: visible },
                        React.createElement(ChevronDownOutlined, { color: disabled ? Color(theme.color.black[500]).alpha(0.5).hsl().string() : theme.color.black[500] }))))));
};
const Option = ListDeprecate.Item;
Select.Option = Option;
