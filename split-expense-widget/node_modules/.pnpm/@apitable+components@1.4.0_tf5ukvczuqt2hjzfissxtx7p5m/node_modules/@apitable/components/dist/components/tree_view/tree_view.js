/**
 * APITable <https://github.com/apitable/apitable>
 * Copyright (C) 2022 APITable Ltd. <https://apitable.com>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
import React, { useCallback, useState, useEffect, Fragment } from 'react';
import TreeViewContext from './tree_view_context';
import { TriangleRightFilled } from '@apitable/icons';
import { TreeItem } from './tree_item';
import { isEqual, isNull } from 'lodash';
import styled, { createGlobalStyle } from 'styled-components';
import { black } from '../../colors';
const TreeViewRoot = styled.ul `
  &.treeViewRoot {
    list-style: none;
    padding: 0;
    margin: 0;
  }
`;
export const TreeView = React.memo(({ module, switcherIcon = React.createElement(TriangleRightFilled, { size: 12, color: black[300] }), switcherLoadingIcon, expandedKeys = null, defaultExpandedKeys = null, selectedKeys = null, defaultSelectedKeys = null, treeData, indent = 24, expandAction = false, multiple = false, draggable = false, loadData, onKeyDown, onSelect, onFocus, onExpand, onRightClick, onLoad, onDragOver, onDrop, children, }) => {
    /**
     * Expanded nodes collection
    */
    const [expandedIds, setExpandedIds] = useState(expandedKeys || defaultExpandedKeys || []);
    /**
     * Selected node collection
    */
    const [selectedIds, setSelectedIds] = useState(selectedKeys || defaultSelectedKeys || []);
    /**
     * Node currently focused
     */
    const [focusedNodeId, setFocusedNodeId] = useState('');
    /**
     * The node ID passed by when dragging a node
     */
    const [dragOverNodeId, setDragOverNodeId] = useState('');
    /**
     * The dragged node
     */
    const [dragNodeId, setDragNodesId] = useState('');
    /**
     * Nodes to highlight
    */
    const [highlightNodeId, setHighlightNodeId] = useState('');
    /**
     * Currently loading data nodes
     */
    const [loadingNodeId, setLoadingNodeId] = useState('');
    const [cacheExpandedIds, setCacheExpandedId] = useState([]);
    useEffect(() => {
        if (isNull(expandedKeys)) {
            return;
        }
        if (isEqual(expandedKeys, expandedIds)) {
            return;
        }
        const filterNodeIds = expandedKeys.filter(expandedKey => !cacheExpandedIds.includes(expandedKey));
        for (const id of filterNodeIds) {
            toggleExpansion(id);
        }
        setExpandedIds(expandedKeys);
        setCacheExpandedId(expandedKeys);
        // eslint-disable-next-line
    }, [expandedKeys]);
    useEffect(() => {
        if (isNull(selectedKeys)) {
            return;
        }
        if (isEqual(selectedIds, selectedKeys)) {
            return;
        }
        setSelectedIds(selectedKeys);
    }, [selectedKeys, selectedIds]);
    const isExpanded = useCallback((id) => ((expandedIds === null || expandedIds === void 0 ? void 0 : expandedIds.length) ? expandedIds.indexOf(id) !== -1 : false), [expandedIds]);
    const isSelected = useCallback((id) => ((selectedIds === null || selectedIds === void 0 ? void 0 : selectedIds.length) ? selectedIds.indexOf(id) !== -1 : false), [selectedIds]);
    const isFocused = (id) => focusedNodeId === id;
    const focus = (e, id) => {
        if (id) {
            setFocusedNodeId(id);
            onFocus && onFocus(e, id);
        }
    };
    const toggleExpansion = (nodeId = focusedNodeId, isAuto = true) => {
        let newExpandedIds;
        /**
         * Determine whether the current operation is an expand operation or a close operation to generate a new set of expanded nodes
        */
        if (expandedIds.includes(nodeId)) {
            newExpandedIds = expandedIds.filter(id => id !== nodeId);
        }
        else {
            newExpandedIds = expandedIds.concat(nodeId);
        }
        /**
         * When manually clicking the expand button
         */
        if (!isAuto) {
            setExpandedIds(newExpandedIds);
            onExpand && onExpand(newExpandedIds);
        }
        /**
         * Asynchronous loading of node data
         */
        if (!expandedIds.includes(nodeId) && loadData) {
            setLoadingNodeId(nodeId);
            return loadData(nodeId).then(() => {
                setExpandedIds(newExpandedIds);
                onLoad && onLoad();
                setLoadingNodeId('');
            });
        }
        return undefined;
    };
    const renderTreeItem = (child, index, level = '0') => {
        const pos = `${level}-${index}`;
        const cloneProps = {
            pos,
        };
        return React.cloneElement(child, cloneProps);
    };
    const singleSelectHandler = (e, nodeId) => {
        const newSelected = multiple ? [nodeId] : [nodeId];
        onSelect && onSelect(e, newSelected);
        setSelectedIds(newSelected);
    };
    const renderTree = (children, parentNode = null, level = '0') => {
        return children.map((node, index) => {
            if (node.children && node.children.length) {
                return React.createElement(TreeItem, { key: node.nodeId, nodeId: node.nodeId, label: node.label, pos: `${level}-${index}`, parentNode: parentNode }, renderTree(node.children, node, level));
            }
            return React.createElement(TreeItem, { key: node.nodeId, nodeId: node.nodeId, label: node.label, pos: `${level}-${index}`, parentNode: parentNode });
        });
    };
    const selectNode = (e, nodeId, multiple = false) => {
        if (nodeId) {
            if (multiple) {
                // TODO: Multiple selection operation
            }
            else {
                singleSelectHandler(e, nodeId);
            }
            return true;
        }
        return false;
    };
    const keyDownHandler = (e) => {
        onKeyDown && onKeyDown(e);
    };
    const dragStart = (treeNode) => {
        setDragNodesId(treeNode.id);
    };
    const dragOver = (treeNode) => {
        onDragOver && onDragOver(Object.assign({ dragNodeId, targetNodeId: treeNode.id }, treeNode));
    };
    const drop = (treeNode) => {
        onDrop && onDrop(treeNode);
        resetState();
    };
    const resetState = () => {
        setDragOverNodeId('');
        setDragNodesId('');
        setHighlightNodeId('');
    };
    const GlobalStyle = createGlobalStyle `
      * {
        box-sizing: border-box;
      }
    `;
    return (React.createElement(Fragment, null,
        React.createElement(GlobalStyle, null),
        React.createElement(TreeViewContext.Provider, { value: {
                module,
                icons: { switcherIcon, switcherLoadingIcon },
                indent,
                multiple,
                draggable,
                dragOverNodeId,
                highlightNodeId,
                dragNodeId,
                loadingNodeId,
                expandAction: expandAction,
                isExpanded,
                isSelected,
                isFocused,
                focus,
                toggleExpansion,
                renderTreeItem,
                selectNode,
                onRightClick,
                dragStart,
                dragOver,
                drop,
            } },
            React.createElement(TreeViewRoot, { role: "tree", className: 'treeViewRoot', "aria-labelledby": "tree_label", onKeyDown: keyDownHandler, tabIndex: 0 }, treeData ? renderTree(treeData) : React.Children.map(children, renderTreeItem)))));
});
