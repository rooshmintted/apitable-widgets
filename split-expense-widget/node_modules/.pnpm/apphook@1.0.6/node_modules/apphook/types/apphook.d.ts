import { FilterCommand, TriggerCommand } from './commands';
import { IRule } from './rules';
import { IListener, ITrigger, IFilter } from './listeners';
import { AddTriggerEvent, DoTriggerEvent, WhenApplyFiltersEvent, AddFilterEvent } from './hook_events';
interface IListenersMap {
    [listenerType: string]: {
        [hook: string]: IListener[];
    };
}
export declare class AppHook {
    /**
     * the place to store all listeners, including Trigger and Filter, store them by type
     *
     * @type {IListenersMap}
     * @memberof AppHook
     */
    _listeners: IListenersMap;
    /**
     * When AddTrigger triggered, the inner event.
     *
     * @type {AddTriggerEvent}
     * @memberof AppHook
     */
    _onAddTrigger: AddTriggerEvent | undefined;
    /**
     * When DoTrigger triggered, the inner event.
     *
     * @type {DoTriggerEvent}
     * @memberof AppHook
     */
    _onDoTrigger: DoTriggerEvent | undefined;
    /**
     * Use for inner self-inspection,
     * the event action that can be bound to useFilters
     *
     * @type {WhenApplyFiltersEvent}
     * @memberof AppHook
     */
    _whenApplyFilters: WhenApplyFiltersEvent | undefined;
    /**
     * When AddFilter triggered, the inner event.
     *
     * @type {AddFilterEvent}
     * @memberof AppHook
     */
    _onAddFilter: AddFilterEvent | undefined;
    /**
     *
     * Add Trigger
     *
     * @param {string} hook
     * @param {TriggerCommand} command
     * @param {*} commandArg
     * @param {(IRule | undefined)} rule
     * @param {number} [priority=0]
     * @param {boolean} [isCatch=false]
     * @returns {ITrigger}
     * @memberof AppHook
     */
    addTrigger(hook: string, command: TriggerCommand, commandArg: any, rule: IRule | undefined, priority?: number, isCatch?: boolean): ITrigger;
    /**
     * Bind AddTriggerEvent, the method will be called when addTrigger
     *
     * @memberof AppHook
     */
    bindAddTrigger(bind: AddTriggerEvent): void;
    /**
     *
     * bind AddFilterEvent, the method will be called when addFilter
     *
     * @param {AddFilterEvent} bind
     * @memberof AppHook
     */
    bindAddFilter(bind: AddFilterEvent): void;
    /**
     * Bind DoTriggerEvent, the method will be called when doTrigger
     *
     * @param {DoTriggerEvent} bind
     * @memberof AppHook
     */
    bindDoTrigger(bind: DoTriggerEvent): void;
    /**
     * binding the method will be called when applyFilters
     *
     * @param {WhenApplyFiltersEvent} bind
     * @memberof AppHook
     */
    bindUseFilters(bind: WhenApplyFiltersEvent): void;
    /**
     *
     * Add filter, filter the default value when event is fired
     *
     * @param {string} hook
     * @param {FilterCommand} command
     * @param {*} commandArg
     * @param {(IRule | undefined)} rule
     * @param {number} [priority=0]
     * @param {boolean} [isCatch=false]
     * @returns {IFilter}
     * @memberof AppHook
     */
    addFilter(hook: string, command: FilterCommand, commandArg: any, rule: IRule | undefined, priority?: number, isCatch?: boolean): IFilter;
    /**
     * add listener to the listeners map
     *
     * @private
     * @param {('Trigger' | 'Filter')} type
     * @param {string} hook hook name
     * @param {IListener} newListener
     * @memberof AppHook
     */
    private addListener;
    /**
     * remove listener
     *
     * @private
     * @param {ListenerType} type
     * @param {IListener} listener
     * @returns {boolean}
     * @memberof AppHook
     */
    private removeListener;
    /**
     * active the trigger, map the trigger to the command
     * no need to consider the priority, because the priority is considered when add trigger
     *
     * @param {string} hook
     * @param {object} [hookState={}] hook event state, optional arguments
     * @memberof AppHook
     */
    doTriggers(hook: string, hookState?: any): void;
    /**
     *
     * remove triggers
     *
     * attention: pass the correct trigger reference(ref func pointer)
     * no deep comparison here
     *
     * @param {ITrigger} trigger
     * @returns {boolean}
     * @memberof AppHook
     */
    removeTrigger(trigger: ITrigger): boolean;
    /**
     * whether has any specified hook name trigger
     *
     * @param {string} hook
     * @returns {boolean}
     * @memberof AppHook
     */
    hasAnyTriggers(hook: string): boolean;
    /**
     * whether has any specified hook name filter
     *
     * @param {string} hook
     * @returns {boolean}
     * @memberof AppHook
     */
    hasAnyFilters(hook: string): boolean;
    /**
     * whether has any specified hook name listener(filter or trigger)
     *
     * @private
     * @param {ListenerType} type
     * @param {string} hook
     * @returns {boolean}
     * @memberof AppHook
     */
    private hasAnyListeners;
    /**
     * remove filter
     *
     * attention: pass the correct trigger reference(ref func pointer)
     * no deep comparison here
     *
     * @param {IFilter} filter
     * @returns {boolean}
     * @memberof AppHook
     */
    removeFilter(filter: IFilter): boolean;
    /**
     * apply filters, trigger the event, and implement multiple filters on the original string
     *
     * @param {string} hook
     * @param {*} defaultValue
     * @param {*} [hookState]
     * @returns {*}
     * @memberof AppHook
     */
    applyFilters(hook: string, defaultValue: any, hookState?: any): any;
}
export {};
