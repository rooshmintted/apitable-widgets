/**
 * APITable <https://github.com/apitable/apitable>
 * Copyright (C) 2022 APITable Ltd. <https://apitable.com>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
/// <reference types="socket.io-client" />
import { databus } from '@apitable/core';
import { CollaCommandManager, ComputeRefManager, Engine, IJOTAction, IReduxState, IResourceOpsCollect, OPEventManager, ResourceStashManager, ResourceType, RoomService, UndoManager } from '../core';
import { Store } from 'redux';
import { IResourceService, IServiceError } from './interface';
export declare const remoteActions2Operation: (actions: IJOTAction[]) => {
    cmd: string;
    actions: IJOTAction[];
};
export declare class ResourceService implements IResourceService {
    store: Store<IReduxState>;
    onError: IServiceError;
    socket: SocketIOClient.Socket;
    roomService: RoomService;
    initialized?: boolean;
    undoManager: UndoManager;
    resourceStashManager: ResourceStashManager;
    opEventManager: OPEventManager;
    computeRefManager: ComputeRefManager;
    reportSocketError: boolean;
    roomIOClear: boolean;
    roomLastSendTime?: number;
    firstRoomInit: boolean;
    private database;
    private databus;
    currentResource: databus.Datasheet | undefined;
    /**
     * @deprecated This is a temporary member. All dependencies of CommandManager in the front-end will be removed in the future.
     */
    readonly commandManager: CollaCommandManager;
    constructor(store: Store<IReduxState>, onError: IServiceError);
    init(): void;
    destroy(): void;
    private static getResourceFetchAction;
    switchResource(params: {
        from?: string;
        to: string;
        resourceType: ResourceType;
        extra?: {
            [key: string]: any;
        };
    }): Promise<void>;
    fetchResource(to: string, resourceType: ResourceType, overWrite?: boolean, extra?: {
        [key: string]: any;
    }): Promise<void>;
    applyOperations(store: Store<IReduxState>, resourceOpsCollects: IResourceOpsCollect[]): void;
    /**
     * @description Simply handle the creation and destruction of rooms, and the creation of undoManager.
     * The point of this method is that it is the same as opening a datasheet,
     * but the concept of destroying/creating a room cannot exist in the "template", so this method is more pure,
     * only call when the concept of room is met.
     * @param {string} to
     * @returns {Promise<void>}
     * @private
     */
    private switchRoom;
    /**
     * @description undoManager is bound to the main resource that created the room,
     * and when switching the resource, it is necessary to instantiate undoManager,
     * and bind undoManager to commandManager.
     * @param {string} resourceId
     */
    createUndoManager(resourceId: string): void;
    /**
     * @description Determine if the current operation is taking place "in the template",
     * no resource in the template needs to create/destroy the room.
     */
    private allowSwitchRoom;
    private createSocket;
    getCollaEngine(resourceId: string): Engine | undefined;
    localOperationDispatch: (resourceOpsCollects: IResourceOpsCollect[]) => void;
    operationExecuted: (resourceOpsCollects: IResourceOpsCollect[]) => void;
    private createDataBus;
    private createDatabase;
    private createCommandManager;
    private beforeUnload;
    private bindBeforeUnload;
    private unBindBeforeUnload;
    /**
     * @description 1. delete the resource data on the store;
     * 2. delete the resource from collaEngineMap provided that the engine has issued an op
     * @param {string} resourceId
     */
    reset(resourceId: string): void;
    onNewChanges(resourceType: ResourceType, resourceId: string, actions: IJOTAction[]): void;
    /**
     * @description Create a collaborative engine (collaEngine) for each resource.
     * @param {string} resourceId
     * @param {ResourceType} resourceType
     * @returns
     */
    createCollaEngine(resourceId: string, resourceType: ResourceType): boolean;
    getCollaEngineKeys(): IterableIterator<string>;
    checkRoomExist(): boolean;
}
//# sourceMappingURL=service.d.ts.map