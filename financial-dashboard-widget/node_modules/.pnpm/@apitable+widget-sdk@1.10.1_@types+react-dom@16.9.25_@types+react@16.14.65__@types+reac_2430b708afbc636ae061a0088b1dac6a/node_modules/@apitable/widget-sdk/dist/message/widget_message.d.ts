import { ICollaCommandExecuteResult, ICollaCommandOptions } from '../core';
import { IExpandRecordProps, IWidgetConfigIframe, IWidgetConfigIframePartial } from '../interface';
import { AnyAction } from 'redux';
import { IFetchDatasheet, IInitData, ISubscribeView } from './interface';
import { ConnectStatus, MessageType, MouseListenerType } from './protocol';
declare class WidgetMessage {
    private target;
    private origin;
    private messageBridge;
    /** Connect status */
    connect: ConnectStatus;
    constructor(widgetId: string);
    /**
     * Messages in the widget, will only communicate with the main thread and will only accept messages from the main thread,
     * so simplify the parameters here.
     * @param type
     * @param callback
     */
    private on;
    /**
     * Messages in the widget, will only communicate with the main thread and
     * will only accept messages from the main thread, so simplify the parameters here.
     * @param type
     * @param data
     */
    private emit;
    /**
     * Listening for connections.
     * @param callback
     */
    connectWidget(callback: () => void): void;
    /**
     * Listening for initialization data from the main thread.
     */
    onInitWidget(callback: (res: IInitData) => void): void;
    /**
     * Listening for config update messages from the main application.
     * @param callback
     */
    onSyncWidgetConfig(callback: (res: IWidgetConfigIframe) => void): void;
    /**
     * Refresh widget.
     * @param callback
     */
    onRefreshWidget(callback: (res: string) => void): void;
    /**
     * Listening from autonomous application action.
     * @param callback
     */
    onSyncAction(callback: (res: AnyAction, messageId?: string) => void): void;
    /**
     * Listening to the selection results from the autonomous application RecordPicker.
     * @param callback
     */
    onSyncRecordPickerResult(callback?: (res: string[], messageId?: string) => void): void;
    /**
     * Synchronize config data to the main application.
     * @param config
     */
    syncWidgetConfig(config: IWidgetConfigIframePartial): void;
    /**
     * Send cmd to main application.
     * @param cmdOptions
     */
    syncCmd(cmdOptions: ICollaCommandOptions): Promise<ICollaCommandExecuteResult<any>>;
    /**
     * Trigger expandRecord.
     * @param expandRecordParams
     */
    expandRecord(expandRecordParams: IExpandRecordProps): void;
    /**
     * Expand Record Selector.
     */
    expandRecordPicker(datasheetId: string): Promise<unknown>;
    /**
     * Mouse in and mouse out widgets iframe.
     * @param type
     */
    mouseListener(type: MouseListenerType): void;
    /**
     * Expand to enter the developer mode pop-up window.
     */
    expandDevConfig(): void;
    /**
     * Loading other datasheet data.
     * @param datasheetId
     */
    fetchDatasheet(fetchDatasheet: IFetchDatasheet): Promise<unknown>;
    /**
     * Synchronizing View Reference Count Subscription Data.
     * @param subscribeViews
     */
    syncWidgetSubscribeView(subscribeViews: ISubscribeView[]): void;
    removeListenEvent(type: MessageType): void;
}
/**
 * Only one message can exist in an widget runtime environment by definition.
 */
export declare let widgetMessage: WidgetMessage;
/**
 * Initialize the widget communication class,
 * you need to pass in the widgetId identifier and the current widget rendering mode.
 * @param widgetId
 * @param sandbox
 */
export declare const initWidgetMessage: (widgetId: string) => WidgetMessage;
export {};
//# sourceMappingURL=widget_message.d.ts.map