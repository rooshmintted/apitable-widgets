import { cloneElement, isValidElement, useCallback, useEffect, useRef, useState } from 'react';
import { useProviderTheme } from '../../../hooks';
import classNames from 'classnames';
import { useDismiss, useRole, useClick, useInteractions, FloatingFocusManager, useId, FloatingArrow, FloatingPortal } from '@floating-ui/react';
import React, { forwardRef, useImperativeHandle } from 'react';
import { useFloatUiDropdown } from './useFloatUiDropdown';
export { setIndex } from './useFloatUiDropdown';
const CONST_INITIAL_DROPDOWN_INDEX = 1002;
export const Dropdown = forwardRef((props, ref) => {
    var _a, _b;
    const { trigger, children, onVisibleChange, options = {
        zIndex: CONST_INITIAL_DROPDOWN_INDEX
    }, className, middleware = [], clazz } = props;
    const arrowEnabled = (_a = options.arrow) !== null && _a !== void 0 ? _a : true;
    const disabled = (_b = options.disabled) !== null && _b !== void 0 ? _b : false;
    const [isOpen, setOpenValue] = useState(false);
    useEffect(() => {
        if ((options === null || options === void 0 ? void 0 : options.visible) != null) {
            setOpenValue(options.visible);
        }
    }, [options === null || options === void 0 ? void 0 : options.visible]);
    const setOpen = useCallback((isOpenState) => {
        if (disabled) {
            return;
        }
        onVisibleChange === null || onVisibleChange === void 0 ? void 0 : onVisibleChange(isOpenState);
        setOpenValue(isOpenState);
    }, [disabled, onVisibleChange]);
    const toggle = useCallback(() => {
        setOpen(!isOpen);
    }, [isOpen, setOpen]);
    const open = useCallback(() => {
        setOpen(true);
    }, [setOpen]);
    const close = useCallback(() => {
        setOpen(false);
    }, [setOpen]);
    useImperativeHandle(ref, () => ({ open, toggle, close }));
    const theme = useProviderTheme();
    const arrowRef = useRef(null);
    const { refs, floatingStyles, context } = useFloatUiDropdown(Object.assign(Object.assign({}, options), { middleware,
        setOpen,
        isOpen,
        arrowRef }));
    const triggerEl = isValidElement(trigger) ? trigger :
        trigger({
            visible: isOpen,
            toggle,
        });
    const click = useClick(context);
    const dismiss = useDismiss(context);
    const role = useRole(context);
    const { getReferenceProps, getFloatingProps } = useInteractions([
        ...((options === null || options === void 0 ? void 0 : options.disableClick) === true ? [] : [click]),
        dismiss,
        role
    ]);
    const headingId = useId();
    const setRef = (v) => {
        var _a;
        refs.setReference(v);
        (_a = props.setTriggerRef) === null || _a === void 0 ? void 0 : _a.call(props, v);
    };
    return (React.createElement(React.Fragment, null,
        React.createElement(React.Fragment, null,
            // @ts-ignore
            cloneElement(triggerEl, Object.assign({ ref: setRef }, getReferenceProps((options === null || options === void 0 ? void 0 : options.stopPropagation) ? {
                onClick: e => e.stopPropagation()
            } : {}))),
            isOpen && (React.createElement(FloatingPortal, null,
                React.createElement(FloatingFocusManager, { context: context },
                    React.createElement("div", Object.assign({ className: classNames(className, clazz === null || clazz === void 0 ? void 0 : clazz.overlay), ref: refs.setFloating, style: floatingStyles, "aria-labelledby": headingId }, getFloatingProps()),
                        children({ toggle }),
                        arrowEnabled && (React.createElement(FloatingArrow, { ref: arrowRef, context: context, fill: theme.color.highestBg, strokeWidth: 1, stroke: theme.color.borderCommonDefault })))))))));
});
