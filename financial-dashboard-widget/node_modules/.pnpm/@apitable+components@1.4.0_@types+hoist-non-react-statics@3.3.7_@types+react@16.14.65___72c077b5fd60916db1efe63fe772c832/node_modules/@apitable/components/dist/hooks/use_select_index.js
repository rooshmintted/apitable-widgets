/**
 * APITable <https://github.com/apitable/apitable>
 * Copyright (C) 2022 APITable Ltd. <https://apitable.com>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
import { useKeyPress } from 'ahooks';
import { getArrayLoopIndex } from '../helper';
import { useEffect, useState } from 'react';
import ReactDOM from 'react-dom';
export const useSelectIndex = (props) => {
    const [index, setIndex] = useState(-1);
    const { inputRef, listContainerRef, onArrowRightPress, onEscapePress, onArrowLeftPress, activeItemClass, listLength, onEnter, containerRef } = props;
    const isEditing = () => {
        var _a;
        if (inputRef) {
            return document.activeElement === ReactDOM.findDOMNode((_a = inputRef.current) === null || _a === void 0 ? void 0 : _a.input) ||
                document.activeElement === inputRef.current;
        }
        if (containerRef) {
            return containerRef.current.contains(document.activeElement);
        }
        return false;
    };
    const updateIndex = (e, plusOrNot) => {
        if (isEditing()) {
            e.preventDefault();
            setIndex(getArrayLoopIndex(listLength, index, plusOrNot));
            // Follow the active item scrolled to the list
            if ((listContainerRef === null || listContainerRef === void 0 ? void 0 : listContainerRef.current) && activeItemClass) {
                const activeElem = listContainerRef.current.querySelector(activeItemClass);
                activeElem && activeElem.scrollIntoView({ block: 'nearest' });
            }
        }
    };
    useEffect(() => {
        setIndex(-1);
        // Reset the index when the length changes
    }, [listLength]);
    useEffect(() => {
        if (!(listContainerRef === null || listContainerRef === void 0 ? void 0 : listContainerRef.current)) {
            return;
        }
        if (index === -1) {
            listContainerRef && listContainerRef.current.scrollTo(0, 0);
        }
    }, [index, listContainerRef]);
    useKeyPress('UpArrow', e => {
        updateIndex(e, -1);
    });
    useKeyPress('DownArrow', e => {
        updateIndex(e, +1);
    });
    useKeyPress('RightArrow', () => {
        onArrowRightPress && onArrowRightPress(index);
    });
    useKeyPress('LeftArrow', () => {
        onArrowLeftPress && onArrowLeftPress(index);
    });
    useKeyPress('Enter', e => {
        e.stopImmediatePropagation();
        e.stopPropagation();
        if (isEditing()) {
            onEnter && index > -1 && onEnter(index);
        }
    });
    useKeyPress('Esc', e => {
        e.stopImmediatePropagation();
        e.stopPropagation();
        onEscapePress && onEscapePress();
    });
    return { index, setIndex };
};
